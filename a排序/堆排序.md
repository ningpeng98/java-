#   堆排序
####	堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
#####	堆排序是选择排序的改进版，它可以减少选择排序法中的比较次数，进而减少排序时间。堆积排序用到了二叉树的技巧，它利用堆积数来完成排序。堆积是一种特殊的二叉树，可分为最大堆积树和最小堆积树：

######	最大堆积树满足三个条件：

 - 是一个完全二叉树
 - 所有节点的值都大于或等于它左右子节点的值
 - 树根是堆积树中最大的

######	最小堆积树也满足三个条件：

  1. 是一个完全二叉树
  2. 所有节点的值都小于或等于它左右子节点的值
  3. 树根是堆积树中最小的

######	开始之前首先需知道：
  1. 对于堆积树中的节点，若节点的下标为n，则它的父节点下标为(n-1)/2;
  2. 若某节点有一个子节点，则其子节点下标为：2n+1,若有两个子节点，则两个子节点下标分别为：2n+1和2n+2
###	堆排序方法（以由小到大排序为例）：
堆排序主要分成两个步骤：
  3. 将无序的数字序列看成数组，再将该数组元素以大根堆的形式重新排列，即将数组改造成一个大根堆。
  4. 大根堆的根节点是整组数据中的最大值，由小到大排序需要将大的值放在后面，所以，将根节点的值与最后一个叶子节点的值进行交换。
  5. 此时，最后一个索引对应的数据可看做已排序区间，之前的所有序列都是未排序区间，但此时整个数组由于数据交换，需要重新组建大根堆，组建过程中已排序区间不受影响。
  6. 数组重新成为大根堆后，再将第一个位置的元素与第二个位置的元素进行交换，此时后两个元素有序，组成已排序区间。
  7. 重复3-4步骤，直到待排序区间只有一个元素，该元素就是整组数据中的最小值，排序完成。
 ####	建最大堆的思路：

  1. 由最后一个叶子节点开始，与其兄弟节点进行比较，找出较大的一个，与它的父亲节点进行比较，若父亲节点大于其子节点，则这个小堆是大根堆；否则将父亲节点与其较大的子节点进行交换，使父亲节点上的值最大，满足大根堆的条件；
  2. 因为是完全二叉树，所以最后一个父亲节点前的所有节点必然都有其子节点，从最后一个父亲节点开始，索引每次减一，按照步骤1中的方法，将每个索引对应的二叉树都变为大根堆积树；
  3. 若在建小堆过程中出现某节点下有比该节点值大的数字的情况，更新根节点索引为这个较大数字的索引，向下寻找，直到把这个最大的值交换到父亲节点的位置；
  4. 当这个二叉树中每个节点对应的子节点都小于自身时，整组数据成为大根堆； 



###	代码（带注释）：
```
import java.util.Arrays;
/***
 * 堆排序
 * 时间复杂度：O(nlog2n)
 * 空间复杂度：O(1)
 * 稳定性：不稳定
 */

public class HeapSort {
    public static void main(String[] args){
        int[] arr = {5,2,-6,8,-3,9,7,4,1,0,-5,3,6};

        System.out.println("排序前：");
        System.out.println(Arrays.toString(arr));
        MyHeapSort(arr);
        System.out.println("MyHeapSort排序后：");
        System.out.println(Arrays.toString(arr));

    }
	//堆排序
    public static void MyHeapSort(int[] arr){
        //i为每棵小子树的根节点
        for (int i = (arr.length-1-1)/2; i >=0 ; i--) {
            //每次调整函数
            adjust(arr,i,arr.length-1);
        }
        //以上for循环结束后，整棵树已全部变为大根堆
        for (int j = 0; j <= arr.length-1 ; j++) {
            int tmp = arr[0];
            arr[0] = arr[arr.length-1-j];
            arr[arr.length-1-j] = tmp;
            adjust(arr,0,arr.length-1-j-1);
            //最后-1是因为最后面的值已经是最大值，相当于已排序区间，不算做下一次调整的

        }
    }


    //一次调整函数，负责把每一棵子树调整为大根堆
    public static void adjust(int[] arr,int start,int end){
        int tmp = arr[start];
        //i=2*i+1在孩子节点中有比父亲节点的值大时，进入孩子节点，重新建堆，将最大的孩子节点提升到父亲节点的位置
        for (int i = 2*start+1; i <= end; i = 2*i+1) {
            //找到最大子树，若2*start+1不是最大值，则2*start+2就是最大值
            if((i<end) && (arr[i]<arr[i+1])){
                i++;//最大值的下标
            }
            //若最大子树大于父亲节点，则将父亲节点的值更改为最大子树的值,且将原本最大子树的索引交给start
            //否则说明父亲节点就是这个二叉树中的最大值，无序改变，退出循环
            if(arr[i]>tmp){
                arr[start] = arr[i];
                start = i;
            }else if (arr[i]<tmp){

                break;
            }

        }
        //将原本父亲节点的值放到原来最大子节点的索引处
        arr[start] = tmp;
    }

}
```
